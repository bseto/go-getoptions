= Parsing CLI Args

The core of the option parser is how CLI Arguments are parsed and how they are mapped to the expected program structure.

The program structure is defined by:
* The options the program expects.
* The commands and sub commands the program can have.
* The options the commands and subcommadns expect.
* The arguments or text input that the program or commands/subcommands expect.

A proper datastructe enables the option parser to easily map CLI Arguments into the items mentioned above.
The wrong datastructure will lead to convoluted APIs.

One unexplored aspect of a proper datastructure is built-in autocompletion of commands, subcommands, options and even in some cases arguments.
In this regard most tools generate a very large bash completion side tool.
go-getoptions in contrast only requires a single line of bash to generate all possible completions.

This documents reflects the datastructure used by go-getoptions that enables trees of commands/subcommands, options, arguments and built-in completion.

== Parsing approach

You cannot parse the CLI Args in isolation, to parse CLI Arguments you require the program datastructure, or at the very least, the option definition in advanced.

The following example will help explain:

    $ ./programname --option some text

When looking at the ambiguous input above you can have the following possibilities (just to name a few):

. Option `--option` with argument `some` plus text input `text`.
. Option `--option` with argument `some` plus command call `text`.
. Option `--option` with command call `some` and argument `text`.
. Option `--option` with arguments `some` and `text` (some CLI parsers allow more than one argument per option).

Now, some option parsers ignore this complexity by forcing ordering.
In other words, no options are allowed before calling a command.
However, even in that case, you can't tell if `--option` expects an argument or not.

=== Program Tree

With the above in mind, the first step before being able to parse CLI Arguments is to build the program's datastructure.
For go-getoptions that datastructure is defined as a double linked tree with a root node.

[source, go]
----
type CLITree struct {
	Type     argType
	Name     string
	Children []*CLITree
	Parent   *CLITree
}
----

There are multiple types of arguments, of particular interest there are:

* argTypeProgname: The root node type.
Holds os.Args[0] as its name.

* argTypeCommand: The node type used for commands and subcommands.

* argTypeOption: The node type used for options.

*	argTypeText: The node type used for regular cli arguments.


Once the tree is built, the parser can walk through the tree as it walks through each of the passed in cli arguments to determine if the argument is an expected option, a command or just a text argument.

Additionally, since there is a datastructure that is walked at the same time as cli arguments are parsed, the parser can suggest next level completions (by listing the children) to the shell completion system.

An example tree can be found in the tests:

This definition:

[source, go]
----
	opt := New()
	opt.String("opt1", "")

	cmd1 := opt.NewCommand("cmd1", "")
	cmd1.String("cmd1opt1", "")
	cmd2 := opt.NewCommand("cmd2", "")
	cmd2.String("cmd2opt1", "")

	sub1cmd1 := cmd1.NewCommand("sub1cmd1", "")
	sub1cmd1.String("sub1cmd1opt1", "")
----

Generates this tree (printed with go-spew):

[source, go]
----
(*getoptions.CLITree)({
	Type: (getoptions.argType) 0,
	Name: (string) (len=47) "/tmp/go-build2358722863/b001/go-getoptions.test",
	Children: ([]*getoptions.CLITree) (len=3) {
		(*getoptions.CLITree)({
			Type: (getoptions.argType) 2,
			Name: (string) (len=4) "opt1",
			Children: ([]*getoptions.CLITree) {
			},
			Parent: (*getoptions.CLITree)(<already shown>)
		}),
		(*getoptions.CLITree)({
			Type: (getoptions.argType) 1,
			Name: (string) (len=4) "cmd1",
			Children: ([]*getoptions.CLITree) (len=2) {
				(*getoptions.CLITree)({
					Type: (getoptions.argType) 2,
					Name: (string) (len=8) "cmd1opt1",
					Children: ([]*getoptions.CLITree) {
					},
					Parent: (*getoptions.CLITree)(<already shown>)
				}),
				(*getoptions.CLITree)({
					Type: (getoptions.argType) 1,
					Name: (string) (len=8) "sub1cmd1",
					Children: ([]*getoptions.CLITree) (len=1) {
						(*getoptions.CLITree)({
							Type: (getoptions.argType) 2,
							Name: (string) (len=12) "sub1cmd1opt1",
							Children: ([]*getoptions.CLITree) {
							},
							Parent: (*getoptions.CLITree)(<already shown>)
						})
					},
					Parent: (*getoptions.CLITree)(<already shown>)
				})
			},
			Parent: (*getoptions.CLITree)(<already shown>)
		}),
		(*getoptions.CLITree)({
			Type: (getoptions.argType) 1,
			Name: (string) (len=4) "cmd2",
			Children: ([]*getoptions.CLITree) (len=1) {
				(*getoptions.CLITree)({
					Type: (getoptions.argType) 2,
					Name: (string) (len=8) "cmd2opt1",
					Children: ([]*getoptions.CLITree) {
					},
					Parent: (*getoptions.CLITree)(<already shown>)
				})
			},
			Parent: (*getoptions.CLITree)(<already shown>)
		})
	},
	Parent: (*getoptions.CLITree)(<nil>)
})
----

=== CLI Arguments Tree




First read the CLI line and the use isOptionV2 on each element to get a list of option pairs.

isOptionV2 - Enhanced version of isOption, this one returns pairs of options and arguments
At this level we don't agregate results in case we have -- and then other options, basically we can parse one option at a time.

type optionPair struct {
	Option string
	// We allow multiple args in case of splitting on comma.
	Args []string
}


== What I want

AST that looks like this:

NOTE: I could start at this level and have an array or CLIargs as a parse result or I could do one level up and have a root CLIarg type with the name of the program.
Having the root level might be helpful with help generation.

CLIarg{
	Type: 0, # 0 - program name, 1 - text, 2 - option, 3 - command, 4 - terminator (--)
	Name: os.Args[0],
	Children: [
		CLIarg{
			Type: 1, # 0 - text, 1 - option, 2 - command, 3 - terminator (--)
			Name: "force",
			Args: [],
			Children: nil,
		},
		CLIarg{
			Type: 1,
			Name: "verbosity",
			Args: [2],
			Children: nil,
		},
		CLIarg{
			Type: 0,
			Name: "sometext_dirname", # Text allowed anywhere, should there be an option for it?
			Args: [],
			Children: nil,
		}
		CLIarg{
			Type: 1,
			Name: "profile",
			Args: ["dev"],
			Children: nil,
		}
		CLIarg{
			Type: 2,
			Name: "command1",
			Args: [],
			Children: [
				CLIarg{
					Type: 2,
					Name: "subcommand1",
					Args: [],
					Children: [
						CLIarg{
							Type: 1,
							Name: "opt1",
							Args: ["hello", "hola,adios"], # split on comma is not done at this level
							Children: nil,
						},
						CLIarg{
							Type: 1,
							Name: "opt2",
							Args: ["lang=en", "def=hello"],
							Children: nil,
						},
						CLIarg{
							Type: 3,
							Name: "--",
							Args: [],
							Children: [
								CLIarg{
									Type: 0,
									Name: "command1", # shouldn't match anything
									Args: [],
									Children, nil,
								},
							],
						},
					],
				},
			],
		},
	],
}
